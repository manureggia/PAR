È il livello che si occupa dei servizi in esecuzione su ogni host, estende il servizio di consegna. I due protocolli principali sono:
- TCP $\rightarrow$ Transfer Control Protocol
- UDP $\rightarrow$ User Datagram Protocol
Le funzionalità minime che deve implementare un protocollo di livello 4 sono:
- **Multiplazione** e **Demultiplazione** dei messaggi tra processi
- rilevamento dell'errore

> il controllo dell'errore del protocollo IP è fatto solo sul suo header e non sul payload, quindi il protocollo IP non prevede un eventuale rilevamento dell'errore

UDP soddisfa solamente le due funzionalità base richieste per essere un protocollo di livello 4, mentre TCP implica anche la trasmissione *affidabile* e la *gestione della congestione di rete*. 

### multiplazione e demultiplazione

UDP e TCP attuano la multiplazione e la demultiplazione includendo due campi speciali nel header:
- n° porta mittente
- n° porta destinatario

## Paradigma Client-Server

Chiamiamo **server** il processo applicativo che per primo si mette in ascolto, mentre chiamiamo **client** quello che inizializza la connessione.

1. SERVER si mette in ascolto (Apertura passiva)
2. CLIEN cerca di inizializzare la comunicazione con un server (Apertura attiva)

>  il server quando si mette in ascolto può fare binding con una porta, ovvero dice al sistema operativo a quale porta il processo è collegato.

> Lo fa anche il Client per ricevere risposte dal server

### Numeri di porta

Nell'header occupano `2 byte`, quindi c'è la disponibilità di 65536 porte, da 0 a 55535, suddivise in 3 categorie:
- `0 - 1023` WELL KNOWN PORTS $\rightarrow$ queste sono associati, a livello standard, a protocolli specifici, spesso utilizzabili e assegnabili solamente con privilegi
- `1024 - 49151` REGISTERED PORTS $\rightarrow$ uso più libero, anche queste possono essere usate da altri protocolli
- `49152 - 65535` DYNAMIC or PRIVATE PORTS $\rightarrow$ dette porte alte, ad uso privato e libero

Un processo client deve sapere preventivamente la porta di destinazione, il fatto che siano standard serve ad evitare la gestione della porta in fase di connessione. Il client ha una porta "meno importante" perché il server conoscerà dinamicamente la porta del client. 
Ogni volta che vediamo un pacchetto che fa uso di un applicativo livello 4 quindi vedremo

```
PORTA DESTINAZIONE | PORTA SORGENTE | TIPO DI PROTOCOLLO
```

> Usiamo il termine **flusso di pacchetti** per identificare pacchetti che appartengono a una stessa comunicazione.

# Protocollo UDP

Protocollo di trasporto leggero e "antico", avente le seguenti caratteristiche:
1. Usa le porte
2. Rileva l'errore
3. Servizio di consegna non garantito, è best-effort i pacchetti possono essere duplicati o persi
4. Servizio senza connessione

## Header

è grande `8 byte`

![[Pasted image 20240207162406.png]]

#### Checksum

calcolato su 3 informazioni:
1. pseudo header ip
2. header UDP
3. payload UDP

Lo pseudo Header IP è formato nel seguente modo

![[Pasted image 20240207162614.png]]

- proto $\rightarrow$ protocollo dell'header IP
- lunghezza $\rightarrow$ stesso del pacchetto UDP, utilizzato per facilitare il calcolo del checksum, deve essere un multiplo di 16bit
L'algoritmo è una somma binaria: ne viene calcolato uno e trasmesso, all'arrivo viene ricalcolato e se risultano uguali vuol dire che non è stato presente nessun errore, altrimenti viene segnalato.

# TCP

È un protocollo affidabile e ha un paradigma di comunicazione:
- orientato alla connessione
- orientato allo **stream** di dati

### Affidabilità

Come avviene la trasmissione affidabile di dati su una infrastruttura inaffidabile? Creiamo una sorta di "canale virtuale", dove controlliamo e gestiamo eventuali errori. Ha la capacità di **rimediare** tramite la ritrasmissione del pacchetto. 

La rilevazione dell'errore avviene tramite checksum, ma questo non ci permette di rilevare un pacchetto perso (perdite), un pacchetto duplicato (duplicati) e che la consegna avvenga in ordine. Questi errori vengono rilevati tramite altri meccanismi.

Ci offre un canale "perfetto" ma ha un costo e può risultare, a seconda del contesto, pesante. Se ci serve un protocollo intermedio si crea un protocollo a partire da UDP

### Rilevare (e rimediare) alla Perdita di pacchetti

- Ogni trasmissione andata a buon fine viene notificata al mittente (**acknowledged**) dall'host ricevente.  Nel caso in cui il pacchetto ricevuto sia errato, l'host ricevente non invia l'ACK, stessa cosa accade nel caso di un pacchetto duplicato $\rightarrow$ il pacchetto ha lo stesso numero di uno già ricevuto, non invio l'ACK
- Se l'host mittente non riceve un acknowledgement entro un intervallo di tempo predefinito (time-out), il mittente ritrasmette i dati

Questa logica si dice di acknowledgement positivo (viene inviato l'ACK solo in caso di trasmissione corretta). Esistono protocolli che inviano anche il NACK, implementarlo comporta costi.
Il **time-out** deve essere scelto in maniera "intelligente", per questo il dimensionamento è fatto in maniera adattiva.

### Orientato alla connessione

Il TCP ha 3 fasi principali:
1. Apertura della connessione
2. utilizzo
3. chiusura della connessione
L'apertura della connessione prevede l'esecuzione prevede l'esecuzione di vari controlli: la disponibilità dell'altro partecipante e stabilire uno stato END-TO-END, ovvero allocare (non a livello di rete) risorse.

TCP implementa la logica di segmentazione del flusso di dati in pacchetti:
- l flusso dati viene separato in tanti **segmenti**
- Viene chiamato **segmento** il blocco di dati che TCP invia a IP per costruire il pacchetto
Il TCP cerca di minimizzare la divisione dei pacchetti:
- cerca di non far frammentare ulteriormente i segmenti TCP

### Affidabilità 

- Le caratteristiche di affidabilità dipendono dal **paradigma di comunicazione**. 
- il tcp essendo orientato alla connessione e orientato a flusso (di byte) deve prevenire l’alterazione dell’intero flusso
- L'apertura e la chiusura della connessione devono essere affidabili
- Tutti i segmenti devono arrivare a destinazione
Altro modo in cui si garantisce affidabilità della frammentazione è attraverso l'identificazione univoca di ogni segmento (numeri di sequenza - **sequence number**) che permette al destinatario di:
- identificare i pacchetti e scartare i duplicati
- riordinare i pacchetti prima di inoltrarli

## Funzionalità

- **trasferimento con BUFFER** gestione dei dati tramite buffer gestito dal sistema operativo (anche dal livello 4 o dalle applicazioni)
- **connessione full duplex** trasferimento contemporaneo. Una volta instaurata la connessione client e server sono alla pari
- **controllo di flusso e congestione**: regola la velocità di invio dei dati scambiati (throughput) rispetto alle capacità degli end (**Flusso**) e della rete (**Congestione**)

### Non garantisce

- comunicazione in tempo reale
- garanzia di disponibilità di banda tra mittente e destinatario
- Multicast affidabile
### Problematiche

- Eterogeneità degli host e delle reti
- possibilità di ritardi nella rete

# Segmento TCP

![[Pasted image 20240207173711.png]]

